###########################################################################
# Installation file of hub2hub (version 0.0.3)
#
# INSTRUCTIONS ############################################################
#
# 1. Run this project as any project to install the hub2hub library
# 2. This project can be deleted from het hub after running it once
# 3. For documenation on how to use this module see:
#    https://hubmodule.readthedocs.io/en/latest/hub2hub
#
###########################################################################
#
# Author: Nard Strijbosch
# Publish date: March 9th 2021
#
# Copyright (C) 2021 Nard Strijbosch
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.If not, see http://www.gnu.org/licenses/
###########################################################################

import os
import hub

install_version = '0.0.3'

files = os.listdir()
filename = 'hub2hub.py'

if filename in files:
    try:
        from hub2hub import version
        if version() < install_version:
            print('An old version is installed')
            os.unlink(filename)
            print('Old version successfully uninstalled')
        else:
            print('The current or a newer version is already installed')
            hub.reset()
    except:
        os.unlink(filename)

print('Start installation')
f = open(filename, 'w')
f.write("import bluetooth\n")
f.write("import random\n")
f.write("import struct\n")
f.write("import time\n")
f.write("import micropython\n")
f.write("import sys\n")
f.write("import gc\n")
f.write("from hub import led, display, Image\n")
f.write("from micropython import const\n")
f.write("\n")
f.write("_IRQ_CENTRAL_CONNECT =        const(1<<0)\n")
f.write("_IRQ_CENTRAL_DISCONNECT =    const(1<<1)\n")
f.write("_IRQ_GATTS_WRITE =            const(1<<2)\n")
f.write("_IRQ_GATTS_READ_REQUEST =    const(1<<3)\n")
f.write("_IRQ_SCAN_RESULT =            const(1<<4)\n")
f.write("_IRQ_SCAN_DONE =            const(1<<5)\n")
f.write("_IRQ_PERIPHERAL_CONNECT =    const(1<<6)\n")
f.write("_IRQ_PERIPHERAL_DISCONNECT =const(1<<7)\n")
f.write("_IRQ_GATTC_WRITE_STATUS =    const(1<<12)\n")
f.write("_IRQ_GATTC_NOTIFY =        const(1<<13) \n")
f.write("\n")
f.write("_ADV_IND =                    const(0x00)\n")
f.write("_ADV_DIRECT_IND =            const(0x01)\n")
f.write("\n")
f.write("_FLAG_READ =                const(0x0002)\n")
f.write("_FLAG_WRITE_NO_RESPONSE =    const(0x0004)\n")
f.write("_FLAG_WRITE =                const(0x0008)\n")
f.write("_FLAG_NOTIFY =                const(0x0010)\n")
f.write("\n")
f.write("_ADV_TYPE_FLAGS = const(0x01)\n")
f.write("_ADV_TYPE_NAME = const(0x09)\n")
f.write("_ADV_TYPE_UUID16_COMPLETE = const(0x3)\n")
f.write("_ADV_TYPE_UUID32_COMPLETE = const(0x5)\n")
f.write("_ADV_TYPE_UUID128_COMPLETE = const(0x7)\n")
f.write("_ADV_TYPE_UUID16_MORE = const(0x2)\n")
f.write("_ADV_TYPE_UUID32_MORE = const(0x4)\n")
f.write("_ADV_TYPE_UUID128_MORE = const(0x6)\n")
f.write("_ADV_TYPE_APPEARANCE = const(0x19)\n")
f.write("\n")
f.write("_UART_SERVICE_UUID = bluetooth.UUID('6ee6d166-6084-11eb-ae93-0242ac130002')\n")
f.write("_UART_RX_CHAR_UUID = bluetooth.UUID('6ee6d3e6-6084-11eb-ae93-0242ac130002')\n")
f.write("_UART_TX_CHAR_UUID = bluetooth.UUID('6ee6d4cc-6084-11eb-ae93-0242ac130002')\n")
f.write("\n")
f.write("_UART_UUID = _UART_SERVICE_UUID\n")
f.write("_UART_TX = (\n")
f.write("    _UART_TX_CHAR_UUID,\n")
f.write("    _FLAG_READ | _FLAG_NOTIFY,\n")
f.write(")\n")
f.write("_UART_RX = (\n")
f.write("    _UART_RX_CHAR_UUID,\n")
f.write("    _FLAG_WRITE | _FLAG_WRITE_NO_RESPONSE,\n")
f.write(")\n")
f.write("_UART_SERVICE = (\n")
f.write("    _UART_UUID,\n")
f.write("    (_UART_TX, _UART_RX),\n")
f.write(")\n")
f.write("\n")
f.write("_CONNECT_IMG_1 = Image('00000:09000:09000:09000:00000')\n")
f.write("_CONNECT_IMG_2 = Image('00000:00900:00900:00900:00000')\n")
f.write("_CONNECT_IMG_3 = Image('00000:00090:00090:00090:00000')\n")
f.write("\n")
f.write("_COMPLETE_IMG = Image('00000:05550:05950:05550:00000')\n")
f.write("\n")
f.write("_CONNECT_PARENT_SEARCH_IMG = Image('00055:00005:00005:00005:00055')\n")
f.write("_CONNECT_CHILDREN_SEARCH_IMG = Image('55000:50000:50000:50000:55000')\n")
f.write("\n")
f.write("_CONNECT_PARENT_FOUND_IMG = Image('00099:00009:00009:00009:00099')\n")
f.write("_CONNECT_CHILDREN_FOUND_IMG = Image('99000:90000:90000:90000:99000')\n")
f.write("\n")
f.write("_CONNECT_ANIMATION_P_S = [_CONNECT_IMG_1+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_2+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_3+_CONNECT_PARENT_SEARCH_IMG]\n")
f.write("\n")
f.write("_CONNECT_ANIMATION_C_S = [_CONNECT_IMG_1+_CONNECT_CHILDREN_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_2+_CONNECT_CHILDREN_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_3+_CONNECT_CHILDREN_SEARCH_IMG]\n")
f.write("\n")
f.write("_CONNECT_ANIMATION_CP_SS = [_CONNECT_IMG_1+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_2+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_3+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_SEARCH_IMG]\n")
f.write("\n")
f.write("_CONNECT_ANIMATION_CP_SF = [_CONNECT_IMG_1+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_FOUND_IMG,\n")
f.write("                        _CONNECT_IMG_2+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_FOUND_IMG,\n")
f.write("                        _CONNECT_IMG_3+_CONNECT_CHILDREN_SEARCH_IMG+_CONNECT_PARENT_FOUND_IMG]\n")
f.write("\n")
f.write("_CONNECT_ANIMATION_CP_FS = [_CONNECT_IMG_1+_CONNECT_CHILDREN_FOUND_IMG+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_2+_CONNECT_CHILDREN_FOUND_IMG+_CONNECT_PARENT_SEARCH_IMG,\n")
f.write("                        _CONNECT_IMG_3+_CONNECT_CHILDREN_FOUND_IMG+_CONNECT_PARENT_SEARCH_IMG]\n")
f.write("\n")
f.write("# Generate a payload to be passed to gap_advertise(adv_data=...).\n")
f.write("def advertising_payload(limited_disc=False, br_edr=False, name=None, services=None, appearance=0):\n")
f.write("    payload = bytearray()\n")
f.write("\n")
f.write("    def _append(adv_type, value):\n")
f.write("        nonlocal payload\n")
f.write("        payload += struct.pack('BB', len(value) + 1, adv_type) + value\n")
f.write("\n")
f.write("    _append(\n")
f.write("        _ADV_TYPE_FLAGS,\n")
f.write("        struct.pack('B', (0x01 if limited_disc else 0x02) + (0x18 if br_edr else 0x04)),\n")
f.write("    )\n")
f.write("\n")
f.write("    if name:\n")
f.write("        _append(_ADV_TYPE_NAME, name)\n")
f.write("\n")
f.write("    if services:\n")
f.write("        for uuid in services:\n")
f.write("            b = bytes(uuid)\n")
f.write("            if len(b) == 2:\n")
f.write("                _append(_ADV_TYPE_UUID16_COMPLETE, b)\n")
f.write("            elif len(b) == 4:\n")
f.write("                _append(_ADV_TYPE_UUID32_COMPLETE, b)\n")
f.write("            elif len(b) == 16:\n")
f.write("                _append(_ADV_TYPE_UUID128_COMPLETE, b)\n")
f.write("\n")
f.write("    # See org.bluetooth.characteristic.gap.appearance.xml\n")
f.write("    if appearance:\n")
f.write("        _append(_ADV_TYPE_APPEARANCE, struct.pack('<h', appearance))\n")
f.write("\n")
f.write("    return payload\n")
f.write("\n")
f.write("def decode_field(payload, adv_type):\n")
f.write("    i = 0\n")
f.write("    result = []\n")
f.write("    while i + 1 < len(payload):\n")
f.write("        if payload[i + 1] == adv_type:\n")
f.write("            result.append(payload[i + 2 : i + payload[i] + 1])\n")
f.write("        i += 1 + payload[i]\n")
f.write("    return result\n")
f.write("\n")
f.write("def decode_name(payload):\n")
f.write("    n = decode_field(payload, _ADV_TYPE_NAME)\n")
f.write("    return str(n[0], 'utf-8') if n else ''\n")
f.write("\n")
f.write("def decode_services(payload):\n")
f.write("    services = []\n")
f.write("    for u in decode_field(payload, _ADV_TYPE_UUID16_COMPLETE):\n")
f.write("        services.append(bluetooth.UUID(struct.unpack('<h', u)[0]))\n")
f.write("    for u in decode_field(payload, _ADV_TYPE_UUID32_COMPLETE):\n")
f.write("        services.append(bluetooth.UUID(struct.unpack('<d', u)[0]))\n")
f.write("    for u in decode_field(payload, _ADV_TYPE_UUID128_COMPLETE):\n")
f.write("        services.append(bluetooth.UUID(u))\n")
f.write("    return services\n")
f.write("\n")
f.write("def on_scan(self, addr_type, addr, connecting_device):\n")
f.write("    if self._debug:\n")
f.write("        print('on scan: ' + str(addr_type) + str(addr))\n")
f.write("    if addr_type is not None:\n")
f.write("        if self._debug:\n")
f.write("            print('Found child: ', connecting_device)\n")
f.write("        self.connect_device()\n")
f.write("    else:\n")
f.write("        self._not_found = True\n")
f.write("        if self._debug:\n")
f.write("            print('No child found.')\n")
f.write("\n")
f.write("class BLEnetwork:\n")
f.write("    def __init__(self, name, network, state=[], debug = False):\n")
f.write("        if debug:\n")
f.write("            print('init')\n")
f.write("        self._ble = bluetooth.BLE()\n")
f.write("        self._ble.active(True)\n")
f.write("        self._debug = debug\n")
f.write("        self._ble.irq(self._irq)\n")
f.write("        self._not_found = False\n")
f.write("        self._name = name\n")
f.write("        self._network = network\n")
f.write("        self._address = network[name]\n")
f.write("        self._set_local_network()\n")
f.write("        self.state = state\n")
f.write("    \n")
f.write("        self._scanning = False\n")
f.write("        self._connecting_device = None\n")
f.write("\n")
f.write("        ## Connection to Parent\n")
f.write("        ((self._handle_tx, self._handle_rx),) = self._ble.gatts_register_services((_UART_SERVICE,))\n")
f.write("        self._ble.gatts_write(self._handle_rx, bytes(100))#set max message size to 100 bytes\n")
f.write("        self._ble.gatts_set_buffer(self._handle_rx, 100)\n")
f.write("        self._ble.gatts_set_buffer(self._handle_tx, 100)        \n")
f.write("        self._conn_handle_parent = None\n")
f.write("        \n")
f.write("        self._response_received = True\n")
f.write("        self._write_callback = None\n")
f.write("        self._payload = advertising_payload(name=name, services=[_UART_UUID])\n")
f.write("\n")
f.write("        self._reset()\n")
f.write("\n")
f.write("    def _reset(self):\n")
f.write("        if self._debug:\n")
f.write("            print(self._name+'reset')\n")
f.write("        # Cached name and address from a successful scan.\n")
f.write("        self._addr_type = None\n")
f.write("        self._addr = None\n")
f.write("\n")
f.write("        # Callbacks for completion of various operations.\n")
f.write("        # These reset back to None after being invoked.\n")
f.write("        self._scan_callback = None\n")
f.write("        self._conn_callback = None\n")
f.write("        self._read_callback = None\n")
f.write("\n")
f.write("        # Persistent callback for when new data is notified from the device.\n")
f.write("        self._notify_callback = None\n")
f.write("        self._on_receive_callback = None\n")
f.write("        \n")
f.write("        self._tx_available = True\n")
f.write("\n")
f.write("        # Connected device.\n")
f.write("        self._conn_handle = [None] * self._nr_children\n")
f.write("        self._tx_handle = 9\n")
f.write("        self._rx_handle = 12\n")
f.write("        \n")
f.write("        if self._debug:\n")
f.write("            print(self._name+'reset_complete')\n")
f.write("        \n")
f.write("\n")
f.write("    def _irq(self, event, data):\n")
f.write("        ### Parent connect\n")
f.write("        if event == _IRQ_CENTRAL_CONNECT:\n")
f.write("            conn_handle, _, _ = data\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: Central Connect')\n")
f.write("                print('New connection', conn_handle)\n")
f.write("            self._conn_handle_parent=conn_handle\n")
f.write("            self._update_animation()\n")
f.write("            \n")
f.write("        ### Parent disconnect\n")
f.write("        elif event == _IRQ_CENTRAL_DISCONNECT:\n")
f.write("            conn_handle, _, _ = data\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: Central Disconnect')\n")
f.write("                print('Disconnected', conn_handle)    \n")
f.write("            self._conn_handle_parent=None\n")
f.write("            self._update_animation()\n")
f.write("            # Start advertising again to allow a new connection.\n")
f.write("            self._advertise()\n")
f.write("            \n")
f.write("        ### Child receiving from Parent on rx\n")
f.write("        elif event == _IRQ_GATTS_WRITE:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: Write')\n")
f.write("            conn_handle, value_handle = data\n")
f.write("            value = self._ble.gatts_read(value_handle)\n")
f.write("            if value_handle == self._handle_rx and self._write_callback:\n")
f.write("                self._write_callback(value.decode())\n")
f.write("        \n")
f.write("        ### Parent scan found BLE device\n")
f.write("        elif event == _IRQ_SCAN_RESULT:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: scan result')\n")
f.write("            addr_type, addr, adv_type, rssi, adv_data = data\n")
f.write("            if adv_type in (_ADV_IND, _ADV_DIRECT_IND) and _UART_SERVICE_UUID in decode_services(adv_data) and (self._children is None or decode_name(adv_data) in self._children):\n")
f.write("                # Found a potential device, remember it and stop scanning.\n")
f.write("                if self._debug:\n")
f.write("                    print('Child:', decode_name(adv_data), 'Recognized')\n")
f.write("                self._connecting_device = decode_name(adv_data)\n")
f.write("                self._addr_type = addr_type\n")
f.write("                self._addr = bytes(\n")
f.write("                    addr\n")
f.write("                )\n")
f.write("                # stop scanning to trigger scan_done\n")
f.write("                self._ble.gap_scan(None)\n")
f.write("\n")
f.write("        ### Parent found possible child\n")
f.write("        elif event == _IRQ_SCAN_DONE:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: scan done')\n")
f.write("            if self._scan_callback:\n")
f.write("                if self._addr:\n")
f.write("                    # Found a device during the scan (and the scan was explicitly stopped).\n")
f.write("                    self._scan_callback(self,self._addr_type, self._addr, self._connecting_device)\n")
f.write("                    #self._scan_callback = None\n")
f.write("                else:\n")
f.write("                    # Scan timed out.\n")
f.write("                    self._scan_callback(self,None, None, None)\n")
f.write("                    self._not_found = True\n")
f.write("\n")
f.write("        ### Child connected to Parent\n")
f.write("        elif event == _IRQ_PERIPHERAL_CONNECT:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: peripheral connect')\n")
f.write("                \n")
f.write("            conn_handle, addr_type, addr = data\n")
f.write("            if addr_type == self._addr_type and addr == self._addr:            \n")
f.write("                self._conn_handle[self._chld_idx[self._connecting_device]]=conn_handle\n")
f.write("                \n")
f.write("                print('Child ' + self._children[self._conn_handle.index(conn_handle)] + ' successfully connected')\n")
f.write("                self._scanning = False\n")
f.write("                self._update_animation()\n")
f.write("\n")
f.write("        ### A child disconnected from Parent\n")
f.write("        elif event == _IRQ_PERIPHERAL_DISCONNECT:\n")
f.write("            # Disconnect (either initiated by us or the remote end).\n")
f.write("            conn_handle, _, _ = data\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+'event: child ' + self._children[self._conn_handle.index(conn_handle)] + ' disconnect')\n")
f.write("            if conn_handle in self._conn_handle:\n")
f.write("                # If it was initiated by us, it'll already be reset.\n")
f.write("                #self._reset()\n")
f.write("                self._conn_handle[self._conn_handle.index(conn_handle)] = None\n")
f.write("                self._update_animation()\n")
f.write("        \n")
f.write("        ### A write from Parent to Child is completed\n")
f.write("        elif event == _IRQ_GATTC_WRITE_STATUS:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+' event: write complete')\n")
f.write("            conn_handle, value_handle, status = data\n")
f.write("            self._tx_available = True\n")
f.write("\n")
f.write("        ### Parent Receives Response from Child\n")
f.write("        elif event == _IRQ_GATTC_NOTIFY:\n")
f.write("            if self._debug:\n")
f.write("                print(self._name+'event: notify')\n")
f.write("            conn_handle, value_handle, notify_data= data\n")
f.write("            self._response_received = True\n")
f.write("            if self._debug:\n")
f.write("                print(notify_data)\n")
f.write("            if not self._parent:\n")
f.write("                if conn_handle in self._conn_handle and value_handle == self._tx_handle:\n")
f.write("                    if self._notify_callback:\n")
f.write("                        self._notify_callback(notify_data.decode())\n")
f.write("            else:\n")
f.write("                self.route_respond_to_root(notify_data.decode())\n")
f.write("        else:\n")
f.write("            if self._debug:\n")
f.write("                print('unknown event:' + str(event))\n")
f.write("            \n")
f.write("    def _set_local_network(self):\n")
f.write("        \n")
f.write("        self.address = self._network[self._name]\n")
f.write("        max_level = len(self.address)\n")
f.write("\n")
f.write("        if '0' in self.address:\n")
f.write("            self._level = self.address.index('0')\n")
f.write("        else:\n")
f.write("            self._level = max_level\n")
f.write("        \n")
f.write("        if self._level > 0:\n")
f.write("            self._parent_address = self.address[:self._level-1] + '0'*(max_level-self._level+1)\n")
f.write("            self._parent = list(self._network.keys())[list(self._network.values()).index(self._parent_address)]\n")
f.write("        else:\n")
f.write("            self._parent_address = None\n")
f.write("            self._parent = None\n")
f.write("            \n")
f.write("        if self._level < max_level:\n")
f.write("            self._children_address = []\n")
f.write("            for child_address in list(self._network.values()):\n")
f.write("                if child_address[:self._level] == self._network[self._name][:self._level] and not (child_address == self._network[self._name]) and not child_address[self._level+1:]>'0'*max_level:\n")
f.write("                    self._children_address.append(child_address)\n")
f.write("            self._children = ['']*len(self._children_address)\n")
f.write("            self._chld_idx = {}\n")
f.write("            for i in range(len(self._children_address)):\n")
f.write("                self._children[i]=list(self._network.keys())[list(self._network.values()).index(self._children_address[i])]\n")
f.write("                self._chld_idx.update({self._children[i]:i})\n")
f.write("            self._nr_children = len(self._children)\n")
f.write("        else:\n")
f.write("            self._children_address = []\n")
f.write("            self._children = []\n")
f.write("            self._chld_idx = {}\n")
f.write("            self._nr_children = 0\n")
f.write("            \n")
f.write("\n")
f.write("    def parent_is_connected(self):\n")
f.write("        return self._conn_handle_parent or (self._parent is None)\n")
f.write("\n")
f.write("    def children_are_connected(self):\n")
f.write("        return self._conn_handle.count(None) is 0\n")
f.write("    # Returns true if we've successfully connected and discovered characteristics.\n")
f.write("    def is_connected(self):\n")
f.write("        return self.children_are_connected() and self.parent_is_connected()\n")
f.write("\n")
f.write("    # Find a device advertising the environmental sensor service.\n")
f.write("    def connect(self, callback=None):\n")
f.write("        self._addr_type = None\n")
f.write("        self._addr = None\n")
f.write("        self._scan_callback = on_scan\n")
f.write("        self._not_found=False\n")
f.write("        \n")
f.write("        self._update_animation()\n")
f.write("        \n")
f.write("        if not self.children_are_connected():\n")
f.write("            print('Connect to children')\n")
f.write("        while not self.children_are_connected():\n")
f.write("            self._ble.gap_scan(20000,30000,30000)\n")
f.write("            self._scanning = True\n")
f.write("            children_to_connect = self._conn_handle.count(None)\n")
f.write("            if self._debug:\n")
f.write("                print(children_to_connect)\n")
f.write("                print(self._conn_handle.count(None))\n")
f.write("            while self._scanning:\n")
f.write("                time.sleep_ms(200)\n")
f.write("                if self._not_found:\n")
f.write("                    self._scanning = False\n")
f.write("                    \n")
f.write("        if not self.parent_is_connected():\n")
f.write("            if self._debug:\n")
f.write("                print('connect parent')\n")
f.write("            self._advertise()\n")
f.write("            \n")
f.write("            while not self.parent_is_connected():\n")
f.write("                pass        \n")
f.write("            \n")
f.write("    ### Responding from child to parent\n")
f.write("    def respond_to_client(self, v):\n")
f.write("        gc.collect()\n")
f.write("        data = {'_f':self._name, '_m':v}\n")
f.write("        try:\n")
f.write("            self._ble.gatts_write(self._handle_tx, str(data))\n")
f.write("            self._ble.gatts_notify(self._conn_handle_parent, self._handle_tx)\n")
f.write("        except:\n")
f.write("            data = self._ble.gatts_read(self._handle_tx)\n")
f.write("            if self._debug:\n")
f.write("                print('read buffer')\n")
f.write("                print(data)\n")
f.write("            \n")
f.write("    ### Route a response from child to parent        \n")
f.write("    def route_respond_to_root(self, data):\n")
f.write("        gc.collect()\n")
f.write("        try:\n")
f.write("            self._ble.gatts_write(self._handle_tx,data)\n")
f.write("            self._ble.gatts_notify(self._conn_handle_parent, self._handle_tx)\n")
f.write("        except:\n")
f.write("            data = self._ble.gatts_read(self._handle_tx)\n")
f.write("            if self._debug:\n")
f.write("                print('read buffer')\n")
f.write("                print(data)\n")
f.write("\n")
f.write("    # Connect to the specified device (otherwise use cached address from a scan).\n")
f.write("    def connect_device(self, addr_type=None, addr=None, callback=None):\n")
f.write("        self._addr_type = addr_type or self._addr_type\n")
f.write("        self._addr = addr or self._addr\n")
f.write("        self._conn_callback = callback\n")
f.write("        if self._addr_type is None or self._addr is None:\n")
f.write("            return False\n")
f.write("        self._ble.gap_connect(self._addr_type, self._addr)\n")
f.write("        return True\n")
f.write("\n")
f.write("# Disconnect children\n")
f.write("    def disconnect(self): \n")
f.write("        for conn_handle in self._conn_handle:\n")
f.write("            if not self._conn_handle[0]:\n")
f.write("                return\n")
f.write("            self._ble.gap_disconnect(conn_handle)\n")
f.write("        self._reset()\n")
f.write("\n")
f.write("    # Sending request from parent to children\n")
f.write("    def request_child(self, child, message, wait_for_response = True):\n")
f.write("        children = [child]\n")
f.write("        if not self.is_connected():\n")
f.write("            return\n")
f.write("        \n")
f.write("        for i in range(len(children)):\n")
f.write("            data = {'_t': self._network[children[i]], '_f':self._name, '_m':message}\n")
f.write("            if self._debug:\n")
f.write("                print('send to: ', children[i])\n")
f.write("            conn_handle = None\n")
f.write("            if children[i] in self._children:\n")
f.write("                conn_handle = self._conn_handle[self._chld_idx[children[i]]]\n")
f.write("            else:\n")
f.write("                for idx in range(len(self._children)):\n")
f.write("                    if self._network[children[i]][:self._level+1] is self._children_address[idx][:self._level+1]:\n")
f.write("                        if self._debug:\n")
f.write("                            print('send via ', self._children[idx])\n")
f.write("                        conn_handle = self._conn_handle[idx]\n")
f.write("            if conn_handle:\n")
f.write("                if self._debug:\n")
f.write("                    print('wait for tx to be available')\n")
f.write("                    led(1)\n")
f.write("                while (not self._tx_available) and (not self._response_received):\n")
f.write("                    pass\n")
f.write("                if self._debug:\n")
f.write("                    led(0)\n")
f.write("                    print('tx available')\n")
f.write("                    print('conn_handle: ', conn_handle)\n")
f.write("                    print('data', str(data))\n")
f.write("                try:\n")
f.write("                    self._ble.gattc_write(conn_handle, self._rx_handle, str(data), 1)\n")
f.write("                    self._tx_available = False\n")
f.write("                    if wait_for_response:\n")
f.write("                        self._response_received = False\n")
f.write("                except:\n")
f.write("                    print('Send to: ' + children[i] + ' failed')\n")
f.write("            else:\n")
f.write("                print('message cannot be send to this hub')\n")
f.write("\n")
f.write("    # Set handler for when data is received over the UART.\n")
f.write("    def set_on_response(self, callback):\n")
f.write("        def on_rx(v):\n")
f.write("            print(v)\n")
f.write("            try:\n")
f.write("                data = eval(v)\n")
f.write("            except:\n")
f.write("                print('A received message is probably to long, this data was collected:' + v)\n")
f.write("                print('Try to reduce the message length')\n")
f.write("                \n")
f.write("            data.setdefault('_f', [])\n")
f.write("            data.setdefault('_m', {})\n")
f.write("            \n")
f.write("            child= data['_f']\n")
f.write("            message = data['_m']\n")
f.write("                        \n")
f.write("            callback(message,child)\n")
f.write("        \n")
f.write("        self._notify_callback = on_rx\n")
f.write("        \n")
f.write("    def set_on_request(self, callback):\n")
f.write("            \n")
f.write("        def on_rx(v):\n")
f.write("            try:\n")
f.write("                data = eval(v)\n")
f.write("            except:\n")
f.write("                print('A received message is probably to long, this data was collected:' + v)\n")
f.write("                print('Try to reduce the message length')\n")
f.write("                \n")
f.write("            data.setdefault('_t', [])\n")
f.write("            data.setdefault('_m', {})                \n")
f.write("\n")
f.write("            if data['_t'] is self._address:    \n")
f.write("                respond_message = callback(data['_m'])\n")
f.write("                if self._debug:\n")
f.write("                    print('respond message', respond_message)\n")
f.write("                if respond_message:\n")
f.write("                    self.respond_to_client(respond_message)\n")
f.write("            else:\n")
f.write("                idx_addressed_child = [idx for idx in range(len(self._children)) if data['_t'][:self._level+1] is self._children_address[idx][:self._level+1]]\n")
f.write("                addressed_child_idx = []\n")
f.write("                for idx in range(len(self._children)):\n")
f.write("                    if self._children_address[idx][:self._level+1] == data['_t'][:self._level+1]:\n")
f.write("                        addressed_child_idx.append(idx)\n")
f.write("                        \n")
f.write("                if len(addressed_child_idx)>0:                    \n")
f.write("                    for idx in addressed_child_idx:\n")
f.write("                        if self._debug:\n")
f.write("                            print('route message to: ' + self._children[idx])\n")
f.write("                        if self._conn_handle[idx]:\n")
f.write("                            if self._debug:\n")
f.write("                                print('wait for tx to be available')\n")
f.write("                                led(1)\n")
f.write("                            while (not self._tx_available) and (not self._response_received):\n")
f.write("                                pass\n")
f.write("                            if self._debug:\n")
f.write("                                print('tx available')\n")
f.write("                                led(0)\n")
f.write("                            self._ble.gattc_write(self._conn_handle[idx], self._rx_handle, str(data), 1)\n")
f.write("                            self._response_received = False\n")
f.write("                            self._tx_available = False\n")
f.write("                        else:\n")
f.write("                            respond_message = {'_err': 'address: ' + data['_t'] + 'not connected'}\n")
f.write("                            self.respond_to_client(respond_message)\n")
f.write("                            if self._debug:\n")
f.write("                                print(respond_message)\n")
f.write("                                print('request received for child that is not connected')\n")
f.write("                else:\n")
f.write("                    respond_message = {'_err': 'address: ' + data['_t'] + 'cannot be reached'}\n")
f.write("                    self.respond_to_client(respond_message)\n")
f.write("                    if self._debug:\n")
f.write("                        print(respond_message)\n")
f.write("                        print('request received for child that cannot be reached from this hub')\n")
f.write("                    \n")
f.write("        self._write_callback = on_rx\n")
f.write("\n")
f.write("    def _advertise(self, interval_us=500000):\n")
f.write("        print('Connect to Parent')\n")
f.write("        self._ble.gap_advertise(interval_us, adv_data=self._payload)\n")
f.write("        \n")
f.write("    def _update_animation(self):\n")
f.write("        if self._debug:\n")
f.write("            print('update animation')\n")
f.write("        if self._parent and len(self._children)>0:\n")
f.write("            if not self.children_are_connected() and not self.parent_is_connected():\n")
f.write("                display.show(_CONNECT_ANIMATION_CP_SS, delay=100, wait=False, loop=True)\n")
f.write("            elif self.parent_is_connected() and not self.children_are_connected():\n")
f.write("                display.show(_CONNECT_ANIMATION_CP_SF, delay=100, wait=False, loop=True)\n")
f.write("            elif not self.parent_is_connected() and self.children_are_connected():\n")
f.write("                display.show(_CONNECT_ANIMATION_CP_FS, delay=100, wait=False, loop=True)\n")
f.write("            else:\n")
f.write("                display.show(_COMPLETE_IMG+_CONNECT_CHILDREN_FOUND_IMG+_CONNECT_PARENT_FOUND_IMG)\n")
f.write("        elif self._parent:\n")
f.write("            if not self.parent_is_connected():\n")
f.write("                display.show(_CONNECT_ANIMATION_P_S, delay=100, wait=False, loop=True)\n")
f.write("            else:\n")
f.write("                display.show(_COMPLETE_IMG+_CONNECT_PARENT_FOUND_IMG)\n")
f.write("        else:\n")
f.write("            if not self.children_are_connected():\n")
f.write("                display.show(_CONNECT_ANIMATION_C_S, delay=100, wait=False, loop=True)\n")
f.write("            else:\n")
f.write("                display.show(_COMPLETE_IMG+_CONNECT_CHILDREN_FOUND_IMG)\n")
f.write("\n")
f.write("def version():\n")
f.write("    return '0.0.3'\n")
f.write("    \n")
f.close()

os.sync()

print('Installation Successfull')
print('hub shutdown')
hub.power_off()
